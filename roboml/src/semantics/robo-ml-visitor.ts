/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import * as ASTInterfaces from '../language/generated/ast.js';
import { LangiumCoreServices, ValidationAcceptor, ValidationChecks } from 'langium';

/**
 * This interface is used to define the visitor methods for the RoboMl language.
 */
export interface RoboMlVisitor {
    visitBlock(node : Block) : any;
    visitElseIf(node : ElseIf) : any;
    visitEntrypoint(node : Entrypoint) : any;
    visitExpression(node : Expression) : any;
    visitBinaryOp(node : BinaryOp) : any;
    visitArithmeticOp(node : ArithmeticOp) : any;
    visitComparisonOp(node : ComparisonOp) : any;
    visitLogicOp(node : LogicOp) : any;
    visitLiteralExpression(node : LiteralExpression) : any;
    visitBooleanConst(node : BooleanConst) : any;
    visitFunctionCall(node : FunctionCall) : any;
    visitNumeralConst(node : NumeralConst) : any;
    visitSensorFunctionCall(node : SensorFunctionCall) : any;
    visitVariableRef(node : VariableRef) : any;
    visitUnaryOp(node : UnaryOp) : any;
    visitNot(node : Not) : any;
    visitOpposite(node : Opposite) : any;
    visitFunctionDef(node : FunctionDef) : any;
    visitRoboProgram(node : RoboProgram) : any;
    visitStatement(node : Statement) : any;
    visitFunctionCallStmt(node : FunctionCallStmt) : any;
    visitIfStmt(node : IfStmt) : any;
    visitLoopStmt(node : LoopStmt) : any;
    visitMovementStmt(node : MovementStmt) : any;
    visitReturnStmt(node : ReturnStmt) : any;
    visitRotationStmt(node : RotationStmt) : any;
    visitSetSpeedStmt(node : SetSpeedStmt) : any;
    visitVariableAffStmt(node : VariableAffStmt) : any;
    visitVariable(node : Variable) : any;
    visitVariableValue(node : VariableValue) : any;
}

/**
 * This abstract class is used to implement a validation visitor for the RoboMl language.
 * It uses the Langium validator service under the hood and exposes its `accept` method through the `validationAccept` property.
 * This `validationAccept` property is reassigned each time the `visitRoot` method is called, so when Langium called the different validation checks.
 */
export abstract class RoboMlValidationVisitor {

    protected validationAccept: ValidationAcceptor = () => {};

    visitRoot(node: RoboProgram, accept: ValidationAcceptor) {
        this.validationAccept = accept;
        node.accept(this);
    }
    
    abstract visitBlock(node : Block) : any;
    abstract visitElseIf(node : ElseIf) : any;
    abstract visitEntrypoint(node : Entrypoint) : any;
    abstract visitExpression(node : Expression) : any;
    abstract visitBinaryOp(node : BinaryOp) : any;
    abstract visitArithmeticOp(node : ArithmeticOp) : any;
    abstract visitComparisonOp(node : ComparisonOp) : any;
    abstract visitLogicOp(node : LogicOp) : any;
    abstract visitLiteralExpression(node : LiteralExpression) : any;
    abstract visitBooleanConst(node : BooleanConst) : any;
    abstract visitFunctionCall(node : FunctionCall) : any;
    abstract visitNumeralConst(node : NumeralConst) : any;
    abstract visitSensorFunctionCall(node : SensorFunctionCall) : any;
    abstract visitVariableRef(node : VariableRef) : any;
    abstract visitUnaryOp(node : UnaryOp) : any;
    abstract visitNot(node : Not) : any;
    abstract visitOpposite(node : Opposite) : any;
    abstract visitFunctionDef(node : FunctionDef) : any;
    abstract visitRoboProgram(node : RoboProgram) : any;
    abstract visitStatement(node : Statement) : any;
    abstract visitFunctionCallStmt(node : FunctionCallStmt) : any;
    abstract visitIfStmt(node : IfStmt) : any;
    abstract visitLoopStmt(node : LoopStmt) : any;
    abstract visitMovementStmt(node : MovementStmt) : any;
    abstract visitReturnStmt(node : ReturnStmt) : any;
    abstract visitRotationStmt(node : RotationStmt) : any;
    abstract visitSetSpeedStmt(node : SetSpeedStmt) : any;
    abstract visitVariableAffStmt(node : VariableAffStmt) : any;
    abstract visitVariable(node : Variable) : any;
    abstract visitVariableValue(node : VariableValue) : any;
}


/**
 * This function is used to register a validation visitor for the RoboMl language.
 * It will register the `visitRoot` method as a validation check for the RoboProgram type.
 * @param visitor - The visitor to register.
 * @param services - The Langium services.
 */
export function registerVisitorAsValidator<T extends RoboMlValidationVisitor>(visitor: T, services: LangiumCoreServices) {
    const registry = services.validation.ValidationRegistry;
    const checks: ValidationChecks<ASTInterfaces.RoboMlAstType> = {
        RoboProgram: (node, accept) => {
            visitor.visitRoot(node as RoboProgram, accept);
        }
    };
    registry.register(checks, visitor);
}


/* Each concrete interfaces in the `ast.js` file have an equivalent generated type with the same properties but also with an `accept` method.
 * While the generated accept-weaver allows us to dynamically add the `accept` function to Langium's types, these types allow it to exist statically, so we can take advantage of TypeScript's typing.
 * The references are overrided to use the visitor types instead of the Langium interfaces/types.
 * Nevertheless, the two are strictly equivalent, and conversion from one to the other is made possible thanks to duck-typing.
 */

type Acceptor = {
    accept: (visitor: RoboMlVisitor) => any;
}

function isAcceptor(node: unknown): node is Acceptor {
    return typeof (node as any).accept === 'function';
}


export type Block = Acceptor & ASTInterfaces.Block

export function isBlock(node: unknown): node is Block {
    return ASTInterfaces.isBlock(node) && isAcceptor(node);
}


export type ElseIf = Acceptor & ASTInterfaces.ElseIf

export function isElseIf(node: unknown): node is ElseIf {
    return ASTInterfaces.isElseIf(node) && isAcceptor(node);
}


export type Entrypoint = Acceptor & ASTInterfaces.Entrypoint

export function isEntrypoint(node: unknown): node is Entrypoint {
    return ASTInterfaces.isEntrypoint(node) && isAcceptor(node);
}


export type Expression = Acceptor & ASTInterfaces.Expression

export function isExpression(node: unknown): node is Expression {
    return ASTInterfaces.isExpression(node) && isAcceptor(node);
}


export type BinaryOp = Acceptor & ASTInterfaces.BinaryOp

export function isBinaryOp(node: unknown): node is BinaryOp {
    return ASTInterfaces.isBinaryOp(node) && isAcceptor(node);
}


export type ArithmeticOp = Acceptor & ASTInterfaces.ArithmeticOp

export function isArithmeticOp(node: unknown): node is ArithmeticOp {
    return ASTInterfaces.isArithmeticOp(node) && isAcceptor(node);
}


export type ComparisonOp = Acceptor & ASTInterfaces.ComparisonOp

export function isComparisonOp(node: unknown): node is ComparisonOp {
    return ASTInterfaces.isComparisonOp(node) && isAcceptor(node);
}


export type LogicOp = Acceptor & ASTInterfaces.LogicOp

export function isLogicOp(node: unknown): node is LogicOp {
    return ASTInterfaces.isLogicOp(node) && isAcceptor(node);
}


export type LiteralExpression = Acceptor & ASTInterfaces.LiteralExpression

export function isLiteralExpression(node: unknown): node is LiteralExpression {
    return ASTInterfaces.isLiteralExpression(node) && isAcceptor(node);
}


export type BooleanConst = Acceptor & ASTInterfaces.BooleanConst

export function isBooleanConst(node: unknown): node is BooleanConst {
    return ASTInterfaces.isBooleanConst(node) && isAcceptor(node);
}


export type FunctionCall = Acceptor & ASTInterfaces.FunctionCall

export function isFunctionCall(node: unknown): node is FunctionCall {
    return ASTInterfaces.isFunctionCall(node) && isAcceptor(node);
}


export type NumeralConst = Acceptor & ASTInterfaces.NumeralConst

export function isNumeralConst(node: unknown): node is NumeralConst {
    return ASTInterfaces.isNumeralConst(node) && isAcceptor(node);
}


export type SensorFunctionCall = Acceptor & ASTInterfaces.SensorFunctionCall

export function isSensorFunctionCall(node: unknown): node is SensorFunctionCall {
    return ASTInterfaces.isSensorFunctionCall(node) && isAcceptor(node);
}


export type VariableRef = Acceptor & ASTInterfaces.VariableRef

export function isVariableRef(node: unknown): node is VariableRef {
    return ASTInterfaces.isVariableRef(node) && isAcceptor(node);
}


export type UnaryOp = Acceptor & ASTInterfaces.UnaryOp

export function isUnaryOp(node: unknown): node is UnaryOp {
    return ASTInterfaces.isUnaryOp(node) && isAcceptor(node);
}


export type Not = Acceptor & ASTInterfaces.Not

export function isNot(node: unknown): node is Not {
    return ASTInterfaces.isNot(node) && isAcceptor(node);
}


export type Opposite = Acceptor & ASTInterfaces.Opposite

export function isOpposite(node: unknown): node is Opposite {
    return ASTInterfaces.isOpposite(node) && isAcceptor(node);
}


export type FunctionDef = Acceptor & ASTInterfaces.FunctionDef

export function isFunctionDef(node: unknown): node is FunctionDef {
    return ASTInterfaces.isFunctionDef(node) && isAcceptor(node);
}


export type RoboProgram = Acceptor & ASTInterfaces.RoboProgram

export function isRoboProgram(node: unknown): node is RoboProgram {
    return ASTInterfaces.isRoboProgram(node) && isAcceptor(node);
}


export type Statement = Acceptor & ASTInterfaces.Statement

export function isStatement(node: unknown): node is Statement {
    return ASTInterfaces.isStatement(node) && isAcceptor(node);
}


export type FunctionCallStmt = Acceptor & ASTInterfaces.FunctionCallStmt

export function isFunctionCallStmt(node: unknown): node is FunctionCallStmt {
    return ASTInterfaces.isFunctionCallStmt(node) && isAcceptor(node);
}


export type IfStmt = Acceptor & ASTInterfaces.IfStmt

export function isIfStmt(node: unknown): node is IfStmt {
    return ASTInterfaces.isIfStmt(node) && isAcceptor(node);
}


export type LoopStmt = Acceptor & ASTInterfaces.LoopStmt

export function isLoopStmt(node: unknown): node is LoopStmt {
    return ASTInterfaces.isLoopStmt(node) && isAcceptor(node);
}


export type MovementStmt = Acceptor & ASTInterfaces.MovementStmt

export function isMovementStmt(node: unknown): node is MovementStmt {
    return ASTInterfaces.isMovementStmt(node) && isAcceptor(node);
}


export type ReturnStmt = Acceptor & ASTInterfaces.ReturnStmt

export function isReturnStmt(node: unknown): node is ReturnStmt {
    return ASTInterfaces.isReturnStmt(node) && isAcceptor(node);
}


export type RotationStmt = Acceptor & ASTInterfaces.RotationStmt

export function isRotationStmt(node: unknown): node is RotationStmt {
    return ASTInterfaces.isRotationStmt(node) && isAcceptor(node);
}


export type SetSpeedStmt = Acceptor & ASTInterfaces.SetSpeedStmt

export function isSetSpeedStmt(node: unknown): node is SetSpeedStmt {
    return ASTInterfaces.isSetSpeedStmt(node) && isAcceptor(node);
}


export type VariableAffStmt = Acceptor & ASTInterfaces.VariableAffStmt

export function isVariableAffStmt(node: unknown): node is VariableAffStmt {
    return ASTInterfaces.isVariableAffStmt(node) && isAcceptor(node);
}


export type Variable = Acceptor & ASTInterfaces.Variable

export function isVariable(node: unknown): node is Variable {
    return ASTInterfaces.isVariable(node) && isAcceptor(node);
}


export type VariableValue = Acceptor & ASTInterfaces.VariableValue

export function isVariableValue(node: unknown): node is VariableValue {
    return ASTInterfaces.isVariableValue(node) && isAcceptor(node);
}


/*
 * Each union type in the `ast.js` file have an equivalent generated type but using the visitor classes instead of the Langium interfaces/types.
 * This type is used to propose the `accept` method of their generated types.
 */

export type ArithmeticOperator = '+' | '-' | '*' | '/';

export type Boolean = string;

export type BooleanOperator = 'and' | 'or';

export type ComparisonOperator = '<' | '<=' | '==' | '>=' | '>' | '!=';

export type Direction = 'Forward' | 'Backward' | 'Left' | 'Right';

export type Double = string;

export type FunctionType = VarType | 'void';

export type MyString = string;

export type RotationDirection = 'Clock' | 'CounterClock';

export type Unit = 'mm' | 'cm';

export type VarType = 'number' | 'bool';
