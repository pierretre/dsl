/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import * as ASTInterfaces from '../language/generated/ast.js';
import { LangiumCoreServices, Reference, ValidationAcceptor, ValidationChecks } from 'langium';

/**
 * This interface is used to define the visitor methods for the RoboMl language.
 */
export interface RoboMlVisitor {
    visitBlock(node : Block) : any;
    visitElseIf(node : ElseIf) : any;
    visitEntrypoint(node : Entrypoint) : any;
    visitExpression(node : Expression) : any;
    visitBinaryOp(node : BinaryOp) : any;
    visitArithmeticOp(node : ArithmeticOp) : any;
    visitComparisonOp(node : ComparisonOp) : any;
    visitLogicOp(node : LogicOp) : any;
    visitLiteralExpression(node : LiteralExpression) : any;
    visitBooleanConst(node : BooleanConst) : any;
    visitFunctionCall(node : FunctionCall) : any;
    visitNumeralConst(node : NumeralConst) : any;
    visitSensorFunctionCall(node : SensorFunctionCall) : any;
    visitVariableRef(node : VariableRef) : any;
    visitUnaryOp(node : UnaryOp) : any;
    visitNot(node : Not) : any;
    visitOpposite(node : Opposite) : any;
    visitFunctionDef(node : FunctionDef) : any;
    visitRoboProgram(node : RoboProgram) : any;
    visitStatement(node : Statement) : any;
    visitFunctionCallStmt(node : FunctionCallStmt) : any;
    visitIfStmt(node : IfStmt) : any;
    visitLoopStmt(node : LoopStmt) : any;
    visitMovementStmt(node : MovementStmt) : any;
    visitReturnStmt(node : ReturnStmt) : any;
    visitRotationStmt(node : RotationStmt) : any;
    visitSetSpeedStmt(node : SetSpeedStmt) : any;
    visitVariableAffStmt(node : VariableAffStmt) : any;
    visitVariable(node : Variable) : any;
    visitVariableValue(node : VariableValue) : any;
}

/**
 * This abstract class is used to implement a validation visitor for the RoboMl language.
 * It uses the Langium validator service under the hood and exposes its `accept` method through the `validationAccept` property.
 * This `validationAccept` property is reassigned each time the `visitRoot` method is called, so when Langium called the different validation checks.
 */
export abstract class RoboMlValidationVisitor {

    protected validationAccept: ValidationAcceptor = () => {};

    visitRoot(node: RoboProgram, accept: ValidationAcceptor) {
        this.validationAccept = accept;
        node.accept(this);
    }
    
    abstract visitBlock(node : Block) : any;
    abstract visitElseIf(node : ElseIf) : any;
    abstract visitEntrypoint(node : Entrypoint) : any;
    abstract visitExpression(node : Expression) : any;
    abstract visitBinaryOp(node : BinaryOp) : any;
    abstract visitArithmeticOp(node : ArithmeticOp) : any;
    abstract visitComparisonOp(node : ComparisonOp) : any;
    abstract visitLogicOp(node : LogicOp) : any;
    abstract visitLiteralExpression(node : LiteralExpression) : any;
    abstract visitBooleanConst(node : BooleanConst) : any;
    abstract visitFunctionCall(node : FunctionCall) : any;
    abstract visitNumeralConst(node : NumeralConst) : any;
    abstract visitSensorFunctionCall(node : SensorFunctionCall) : any;
    abstract visitVariableRef(node : VariableRef) : any;
    abstract visitUnaryOp(node : UnaryOp) : any;
    abstract visitNot(node : Not) : any;
    abstract visitOpposite(node : Opposite) : any;
    abstract visitFunctionDef(node : FunctionDef) : any;
    abstract visitRoboProgram(node : RoboProgram) : any;
    abstract visitStatement(node : Statement) : any;
    abstract visitFunctionCallStmt(node : FunctionCallStmt) : any;
    abstract visitIfStmt(node : IfStmt) : any;
    abstract visitLoopStmt(node : LoopStmt) : any;
    abstract visitMovementStmt(node : MovementStmt) : any;
    abstract visitReturnStmt(node : ReturnStmt) : any;
    abstract visitRotationStmt(node : RotationStmt) : any;
    abstract visitSetSpeedStmt(node : SetSpeedStmt) : any;
    abstract visitVariableAffStmt(node : VariableAffStmt) : any;
    abstract visitVariable(node : Variable) : any;
    abstract visitVariableValue(node : VariableValue) : any;
}


/**
 * This function is used to register a validation visitor for the RoboMl language.
 * It will register the `visitRoot` method as a validation check for the RoboProgram type.
 * @param visitor - The visitor to register.
 * @param services - The Langium services.
 */
export function registerVisitorAsValidator<T extends RoboMlValidationVisitor>(visitor: T, services: LangiumCoreServices) {
    const registry = services.validation.ValidationRegistry;
    const checks: ValidationChecks<ASTInterfaces.RoboMlAstType> = {
        RoboProgram: (node, accept) => {
            visitor.visitRoot(node as RoboProgram, accept);
        }
    };
    registry.register(checks, visitor);
}


/* Each concrete interfaces in the `ast.js` file have an equivalent generated class with the same properties but also with an `accept` method.
 * While the generated accept-weaver allows us to dynamically add the `accept` function to Langium's types, these classes allow it to exist statically, so we can take advantage of TypeScript's typing.
 * Nevertheless, the two are strictly equivalent, and conversion from one to the other is made possible thanks to duck-typing.
 */

export class Block implements ASTInterfaces.Block {
    
    constructor(public $type: 'Block', public $container: ElseIf | Entrypoint | FunctionDef | IfStmt | LoopStmt, public statements: Statement[]) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
        return visitor.visitBlock(this);
    }
}

export class ElseIf implements ASTInterfaces.ElseIf {
    
    constructor(public $type: 'ElseIf', public $container: IfStmt, public condition: Expression, public thenBlock: Block) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
        return visitor.visitElseIf(this);
    }
}

export class Entrypoint implements ASTInterfaces.Entrypoint {
    
    constructor(public $type: 'Entrypoint', public $container: RoboProgram, public body: Block) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
        return visitor.visitEntrypoint(this);
    }
}

export class Expression implements ASTInterfaces.Expression {
    
    constructor(public $type: 'Expression' | 'BinaryOp' | 'ArithmeticOp' | 'ComparisonOp' | 'LogicOp' | 'LiteralExpression' | 'BooleanConst' | 'FunctionCall' | 'NumeralConst' | 'SensorFunctionCall' | 'VariableRef' | 'UnaryOp' | 'Not' | 'Opposite', public unit: Unit) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
    }
}

export class BinaryOp extends Expression implements ASTInterfaces.BinaryOp {
    
    constructor(public override $type: 'BinaryOp' | 'ArithmeticOp' | 'ComparisonOp' | 'LogicOp', public override unit: Unit, public left: Expression, public right: Expression) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
    }
}

export class ArithmeticOp extends BinaryOp implements ASTInterfaces.ArithmeticOp {
    
    constructor(public override $type: 'ArithmeticOp', public override unit: Unit, public override left: Expression, public override right: Expression, public operator: ArithmeticOperator) {
        super($type, unit, left, right);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitArithmeticOp(this);
    }
}

export class ComparisonOp extends BinaryOp implements ASTInterfaces.ComparisonOp {
    
    constructor(public override $type: 'ComparisonOp', public override unit: Unit, public override left: Expression, public override right: Expression, public operator: ComparisonOperator) {
        super($type, unit, left, right);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitComparisonOp(this);
    }
}

export class LogicOp extends BinaryOp implements ASTInterfaces.LogicOp {
    
    constructor(public override $type: 'LogicOp', public override unit: Unit, public override left: Expression, public override right: Expression, public operator: BooleanOperator) {
        super($type, unit, left, right);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitLogicOp(this);
    }
}

export class LiteralExpression extends Expression implements ASTInterfaces.LiteralExpression {
    
    constructor(public override $type: 'LiteralExpression' | 'BooleanConst' | 'FunctionCall' | 'NumeralConst' | 'SensorFunctionCall' | 'VariableRef', public override unit: Unit) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
    }
}

export class BooleanConst extends LiteralExpression implements ASTInterfaces.BooleanConst {
    
    constructor(public override $type: 'BooleanConst', public override unit: Unit, public value: boolean) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitBooleanConst(this);
    }
}

export class FunctionCall extends LiteralExpression implements ASTInterfaces.FunctionCall {
    
    constructor(public override $type: 'FunctionCall', public override unit: Unit, public ref: Reference<FunctionDef>, public parameters: Expression[]) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitFunctionCall(this);
    }
}

export class NumeralConst extends LiteralExpression implements ASTInterfaces.NumeralConst {
    
    constructor(public override $type: 'NumeralConst', public override unit: Unit, public value: number) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitNumeralConst(this);
    }
}

export class SensorFunctionCall extends LiteralExpression implements ASTInterfaces.SensorFunctionCall {
    
    constructor(public override $type: 'SensorFunctionCall', public override unit: Unit) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitSensorFunctionCall(this);
    }
}

export class VariableRef extends LiteralExpression implements ASTInterfaces.VariableRef {
    
    constructor(public override $type: 'VariableRef', public override unit: Unit, public decl: Reference<Variable>) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitVariableRef(this);
    }
}

export class UnaryOp extends Expression implements ASTInterfaces.UnaryOp {
    
    constructor(public override $type: 'UnaryOp' | 'Not' | 'Opposite', public override unit: Unit, public expr: Expression) {
        super($type, unit);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
    }
}

export class Not extends UnaryOp implements ASTInterfaces.Not {
    
    constructor(public override $type: 'Not', public override unit: Unit, public override expr: Expression) {
        super($type, unit, expr);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitNot(this);
    }
}

export class Opposite extends UnaryOp implements ASTInterfaces.Opposite {
    
    constructor(public override $type: 'Opposite', public override unit: Unit, public override expr: Expression) {
        super($type, unit, expr);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitOpposite(this);
    }
}

export class FunctionDef implements ASTInterfaces.FunctionDef {
    
    constructor(public $type: 'FunctionDef', public $container: RoboProgram, public name: string, public parameters: Variable[], public returnType: FunctionType, public body: Block) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
        return visitor.visitFunctionDef(this);
    }
}

export class RoboProgram implements ASTInterfaces.RoboProgram {
    
    constructor(public $type: 'RoboProgram', public entrypoint: Entrypoint, public defs: FunctionDef[]) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
        return visitor.visitRoboProgram(this);
    }
}

export class Statement implements ASTInterfaces.Statement {
    
    constructor(public $type: 'Statement' | 'FunctionCallStmt' | 'IfStmt' | 'LoopStmt' | 'MovementStmt' | 'ReturnStmt' | 'RotationStmt' | 'SetSpeedStmt' | 'VariableAffStmt') {
    }
    
     accept(visitor: RoboMlVisitor) : any {
    }
}

export class FunctionCallStmt extends Statement implements ASTInterfaces.FunctionCallStmt {
    
    constructor(public override $type: 'FunctionCallStmt', public parameters: Expression[], public voidfct: Reference<FunctionDef>) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitFunctionCallStmt(this);
    }
}

export class IfStmt extends Statement implements ASTInterfaces.IfStmt {
    
    constructor(public override $type: 'IfStmt', public condition: Expression, public thenBlock: Block, public elseBlock: Block, public elseif: ElseIf[]) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitIfStmt(this);
    }
}

export class LoopStmt extends Statement implements ASTInterfaces.LoopStmt {
    
    constructor(public override $type: 'LoopStmt', public condition: Expression, public block: Block) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitLoopStmt(this);
    }
}

export class MovementStmt extends Statement implements ASTInterfaces.MovementStmt {
    
    constructor(public override $type: 'MovementStmt', public direction: Direction, public expr: Expression) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitMovementStmt(this);
    }
}

export class ReturnStmt extends Statement implements ASTInterfaces.ReturnStmt {
    
    constructor(public override $type: 'ReturnStmt', public expr: Expression) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitReturnStmt(this);
    }
}

export class RotationStmt extends Statement implements ASTInterfaces.RotationStmt {
    
    constructor(public override $type: 'RotationStmt', public rotation: RotationDirection, public degrees: Expression) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitRotationStmt(this);
    }
}

export class SetSpeedStmt extends Statement implements ASTInterfaces.SetSpeedStmt {
    
    constructor(public override $type: 'SetSpeedStmt', public value: Expression) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitSetSpeedStmt(this);
    }
}

export class VariableAffStmt extends Statement implements ASTInterfaces.VariableAffStmt {
    
    constructor(public override $type: 'VariableAffStmt', public decl: Reference<Variable>, public expr: Expression) {
        super($type);
    }
    
    override accept(visitor: RoboMlVisitor) : any {
        return visitor.visitVariableAffStmt(this);
    }
}

export class Variable implements ASTInterfaces.Variable {
    
    constructor(public $type: 'Variable', public $container: FunctionDef, public name: string, public type: VarType, public value: VariableValue) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
        return visitor.visitVariable(this);
    }
}

export class VariableValue implements ASTInterfaces.VariableValue {
    
    constructor(public $type: 'VariableValue', public $container: Variable, public value: Expression) {
    }
    
     accept(visitor: RoboMlVisitor) : any {
        return visitor.visitVariableValue(this);
    }
}


/*
 * Each union type in the `ast.js` file have an equivalent generated type but using the visitor classes instead of the Langium interfaces/types.
 * This type is used to propose the `accept` method of their generated classes.
 */


export type ArithmeticOperator = '+' | '-' | '*' | '/';

export type Boolean = string;

export type BooleanOperator = 'and' | 'or';

export type ComparisonOperator = '<' | '<=' | '==' | '>=' | '>' | '!=';

export type Direction = 'Forward' | 'Backward' | 'Left' | 'Right';

export type Double = string;

export type FunctionType = VarType | 'void';

export type MyString = string;

export type RotationDirection = 'Clock' | 'CounterClock';

export type Unit = 'mm' | 'cm';

export type VarType = 'number' | 'bool';
