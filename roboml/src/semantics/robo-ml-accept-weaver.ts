/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import { AstNode, AstUtils, ContextCache, DocumentState, LangiumCoreServices } from 'langium';
import type { RoboMlAstType } from '../language/generated/ast.js';
import * as InterfaceAST from '../language/generated/ast.js';
import * as ClassAST from './robo-ml-visitor.js';
import { RoboMlVisitor } from './robo-ml-visitor.js';
import { DiagnosticSeverity } from 'vscode-languageserver';


type Weaver = {
    [K in keyof RoboMlAstType]?: (node: RoboMlAstType[K]) => void;
}

/**
 * This class is used to dynamically add an `accept` method to the Langium generated (concrete) types.
 * It is executed when each time a Langium document goes in "IndexedReferences" state, before the validation phase, but use a cache to avoid reweaving the same AST nodes multiple times.
 */
export class RoboMlAcceptWeaver {
    
    private readonly checks: Weaver = {
        Block: this.weaveBlock,
        ElseIf: this.weaveElseIf,
        Entrypoint: this.weaveEntrypoint,
        ArithmeticOp: this.weaveArithmeticOp,
        ComparisonOp: this.weaveComparisonOp,
        LogicOp: this.weaveLogicOp,
        BooleanConst: this.weaveBooleanConst,
        FunctionCall: this.weaveFunctionCall,
        NumeralConst: this.weaveNumeralConst,
        SensorFunctionCall: this.weaveSensorFunctionCall,
        VariableRef: this.weaveVariableRef,
        Not: this.weaveNot,
        Opposite: this.weaveOpposite,
        FunctionDef: this.weaveFunctionDef,
        RoboProgram: this.weaveRoboProgram,
        FunctionCallStmt: this.weaveFunctionCallStmt,
        IfStmt: this.weaveIfStmt,
        LoopStmt: this.weaveLoopStmt,
        MovementStmt: this.weaveMovementStmt,
        ReturnStmt: this.weaveReturnStmt,
        RotationStmt: this.weaveRotationStmt,
        SetSpeedStmt: this.weaveSetSpeedStmt,
        VariableAffStmt: this.weaveVariableAffStmt,
        Variable: this.weaveVariable,
        VariableValue: this.weaveVariableValue
    };

    private readonly cache: ContextCache<AstNode, string, void>;

    constructor(services: LangiumCoreServices) {
        this.cache = new ContextCache<AstNode, string, void>();
        services.shared.workspace.DocumentBuilder.onDocumentPhase(DocumentState.IndexedReferences, (document) => {
            if(!document.diagnostics || document.diagnostics.filter(d => d.severity === DiagnosticSeverity.Error).length === 0) {
                AstUtils.streamAst(document.parseResult.value).forEach((node: AstNode) => {
                    if(!this.cache.has(node, 'weaved')) {
                        const nodeType = node.$type as keyof Weaver;
                        const weaveFunction = this.checks[nodeType]; 
                        if (weaveFunction) {
                            weaveFunction(node as any);
                            this.cache.set(node, 'weaved', undefined);
                        }
                    }
                });
            }
        });
    }

    
    weaveBlock(node : InterfaceAST.Block) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitBlock(node as unknown as ClassAST.Block); }
    }
    
    weaveElseIf(node : InterfaceAST.ElseIf) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitElseIf(node as unknown as ClassAST.ElseIf); }
    }
    
    weaveEntrypoint(node : InterfaceAST.Entrypoint) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitEntrypoint(node as unknown as ClassAST.Entrypoint); }
    }
    
    weaveArithmeticOp(node : InterfaceAST.ArithmeticOp) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitArithmeticOp(node as unknown as ClassAST.ArithmeticOp); }
    }
    
    weaveComparisonOp(node : InterfaceAST.ComparisonOp) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitComparisonOp(node as unknown as ClassAST.ComparisonOp); }
    }
    
    weaveLogicOp(node : InterfaceAST.LogicOp) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitLogicOp(node as unknown as ClassAST.LogicOp); }
    }
    
    weaveBooleanConst(node : InterfaceAST.BooleanConst) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitBooleanConst(node as unknown as ClassAST.BooleanConst); }
    }
    
    weaveFunctionCall(node : InterfaceAST.FunctionCall) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitFunctionCall(node as unknown as ClassAST.FunctionCall); }
    }
    
    weaveNumeralConst(node : InterfaceAST.NumeralConst) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitNumeralConst(node as unknown as ClassAST.NumeralConst); }
    }
    
    weaveSensorFunctionCall(node : InterfaceAST.SensorFunctionCall) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitSensorFunctionCall(node as unknown as ClassAST.SensorFunctionCall); }
    }
    
    weaveVariableRef(node : InterfaceAST.VariableRef) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitVariableRef(node as unknown as ClassAST.VariableRef); }
    }
    
    weaveNot(node : InterfaceAST.Not) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitNot(node as unknown as ClassAST.Not); }
    }
    
    weaveOpposite(node : InterfaceAST.Opposite) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitOpposite(node as unknown as ClassAST.Opposite); }
    }
    
    weaveFunctionDef(node : InterfaceAST.FunctionDef) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitFunctionDef(node as unknown as ClassAST.FunctionDef); }
    }
    
    weaveRoboProgram(node : InterfaceAST.RoboProgram) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitRoboProgram(node as unknown as ClassAST.RoboProgram); }
    }
    
    weaveFunctionCallStmt(node : InterfaceAST.FunctionCallStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitFunctionCallStmt(node as unknown as ClassAST.FunctionCallStmt); }
    }
    
    weaveIfStmt(node : InterfaceAST.IfStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitIfStmt(node as unknown as ClassAST.IfStmt); }
    }
    
    weaveLoopStmt(node : InterfaceAST.LoopStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitLoopStmt(node as unknown as ClassAST.LoopStmt); }
    }
    
    weaveMovementStmt(node : InterfaceAST.MovementStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitMovementStmt(node as unknown as ClassAST.MovementStmt); }
    }
    
    weaveReturnStmt(node : InterfaceAST.ReturnStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitReturnStmt(node as unknown as ClassAST.ReturnStmt); }
    }
    
    weaveRotationStmt(node : InterfaceAST.RotationStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitRotationStmt(node as unknown as ClassAST.RotationStmt); }
    }
    
    weaveSetSpeedStmt(node : InterfaceAST.SetSpeedStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitSetSpeedStmt(node as unknown as ClassAST.SetSpeedStmt); }
    }
    
    weaveVariableAffStmt(node : InterfaceAST.VariableAffStmt) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitVariableAffStmt(node as unknown as ClassAST.VariableAffStmt); }
    }
    
    weaveVariable(node : InterfaceAST.Variable) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitVariable(node as unknown as ClassAST.Variable); }
    }
    
    weaveVariableValue(node : InterfaceAST.VariableValue) : void {
        (<any> node).accept = (visitor: RoboMlVisitor) => { return visitor.visitVariableValue(node as unknown as ClassAST.VariableValue); }
    }
    
}